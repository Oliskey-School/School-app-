-- Phase 11: Step 16 Security & Data Protection

-- 1. Create Audit Logs Table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id),
    action TEXT NOT NULL, -- 'INSERT', 'UPDATE', 'DELETE'
    table_name TEXT NOT NULL,
    record_id TEXT,
    old_data JSONB,
    new_data JSONB,
    client_ip TEXT,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Immutable constraint: prevent updates or deletes to audit logs
    CONSTRAINT immutable_logs CHECK (TRUE)
);

-- 2. Prevent updates/deletes on audit_logs
CREATE OR REPLACE FUNCTION public.prevent_log_mutation()
RETURNS TRIGGER AS $$
BEGIN
    RAISE EXCEPTION 'Audit logs are immutable and cannot be modified or deleted.';
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_prevent_audit_mutation
BEFORE UPDATE OR DELETE ON public.audit_logs
FOR EACH ROW EXECUTE FUNCTION public.prevent_log_mutation();

-- 3. Generic Audit Trigger Function
CREATE OR REPLACE FUNCTION public.process_audit_log()
RETURNS TRIGGER AS $$
DECLARE
    curr_user_id UUID;
BEGIN
    curr_user_id := auth.uid();
    
    IF (TG_OP = 'DELETE') THEN
        INSERT INTO public.audit_logs (user_id, action, table_name, record_id, old_data)
        VALUES (curr_user_id, 'DELETE', TG_TABLE_NAME, OLD.id::text, row_to_json(OLD)::jsonb);
        RETURN OLD;
    ELSIF (TG_OP = 'UPDATE') THEN
        INSERT INTO public.audit_logs (user_id, action, table_name, record_id, old_data, new_data)
        VALUES (curr_user_id, 'UPDATE', TG_TABLE_NAME, NEW.id::text, row_to_json(OLD)::jsonb, row_to_json(NEW)::jsonb);
        RETURN NEW;
    ELSIF (TG_OP = 'INSERT') THEN
        INSERT INTO public.audit_logs (user_id, action, table_name, record_id, new_data)
        VALUES (curr_user_id, 'INSERT', TG_TABLE_NAME, NEW.id::text, row_to_json(NEW)::jsonb);
        RETURN NEW;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- 4. Apply Triggers to Sensitive Tables
DO $$
BEGIN
    -- Fees
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'fees') THEN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'tr_audit_fees') THEN
            CREATE TRIGGER tr_audit_fees AFTER INSERT OR UPDATE OR DELETE ON public.fees FOR EACH ROW EXECUTE FUNCTION public.process_audit_log();
        END IF;
    END IF;

    -- Students
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'students') THEN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'tr_audit_students') THEN
            CREATE TRIGGER tr_audit_students AFTER INSERT OR UPDATE OR DELETE ON public.students FOR EACH ROW EXECUTE FUNCTION public.process_audit_log();
        END IF;
    END IF;
    
    -- Academic Records
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'academic_records') THEN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'tr_audit_records') THEN
            CREATE TRIGGER tr_audit_records AFTER INSERT OR UPDATE OR DELETE ON public.academic_records FOR EACH ROW EXECUTE FUNCTION public.process_audit_log();
        END IF;
    END IF;
END $$;

-- 5. RLS for Audit Logs
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can view all audit logs" 
ON public.audit_logs FOR SELECT 
USING (auth.jwt() ->> 'role' = 'admin');
