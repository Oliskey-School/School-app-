{"ast":null,"code":"import { supabase } from './supabase';\nexport async function fetchStudentFees(studentId) {\n  const {\n    data,\n    error\n  } = await supabase.from('fees').select('*').eq('student_id', studentId).order('due_date', {\n    ascending: true\n  });\n  if (error) {\n    console.error('Error fetching fees:', error);\n    return [];\n  }\n  return data.map(normalizeFee);\n}\nexport async function fetchAllFees() {\n  const {\n    data,\n    error\n  } = await supabase.from('fees').select('*').order('created_at', {\n    ascending: false\n  });\n  if (error) {\n    console.error('Error fetching all fees:', error);\n    return [];\n  }\n  return data.map(normalizeFee);\n}\nexport async function assignFee(fee) {\n  const {\n    data,\n    error\n  } = await supabase.from('fees').insert([{\n    student_id: fee.studentId,\n    title: fee.title,\n    description: fee.description,\n    amount: fee.amount,\n    due_date: fee.dueDate,\n    status: 'pending',\n    paid_amount: 0,\n    curriculum_type: fee.curriculumType || 'General'\n  }]).select().single();\n  if (error) {\n    console.error('Error assigning fee:', error);\n    throw error;\n  }\n  return normalizeFee(data);\n}\nexport async function initializeTransaction(feeId, studentId, amount, reference, provider = 'Paystack') {\n  const {\n    data: {\n      user\n    }\n  } = await supabase.auth.getUser();\n  const {\n    error\n  } = await supabase.from('transactions').insert([{\n    fee_id: feeId,\n    student_id: studentId,\n    payer_id: user?.id,\n    amount,\n    reference,\n    provider,\n    status: 'pending'\n  }]);\n  if (error) {\n    console.error('Error initializing transaction:', error);\n  }\n}\nexport async function verifyTransaction(reference) {\n  try {\n    const {\n      data: transaction,\n      error: txError\n    } = await supabase.from('transactions').update({\n      status: 'success'\n    }).eq('reference', reference).select().single();\n    if (txError || !transaction) throw new Error('Transaction not found or update failed');\n    const feeId = transaction.fee_id;\n    if (feeId) {\n      const {\n        data: fee\n      } = await supabase.from('fees').select('amount, paid_amount').eq('id', feeId).single();\n      if (fee) {\n        const newPaidAmount = (fee.paid_amount || 0) + transaction.amount;\n        const newStatus = newPaidAmount >= fee.amount ? 'paid' : 'partial';\n        await supabase.from('fees').update({\n          paid_amount: newPaidAmount,\n          status: newStatus,\n          updated_at: new Date().toISOString()\n        }).eq('id', feeId);\n      }\n    }\n    return {\n      success: true,\n      message: 'Payment verified successfully'\n    };\n  } catch (err) {\n    console.error('Payment verification error:', err);\n    return {\n      success: false,\n      message: err.message\n    };\n  }\n}\nexport async function fetchPaymentHistory(studentId) {\n  let query = supabase.from('transactions').select('*').order('created_at', {\n    ascending: false\n  });\n  if (studentId) {\n    query = query.eq('student_id', studentId);\n  }\n  const {\n    data,\n    error\n  } = await query;\n  if (error) return [];\n  return data.map(normalizeTransaction);\n}\nfunction normalizeFee(data) {\n  return {\n    id: data.id,\n    studentId: data.student_id,\n    title: data.title,\n    description: data.description,\n    amount: data.amount,\n    paidAmount: data.paid_amount,\n    dueDate: data.due_date,\n    status: mapStatus(data.status),\n    type: data.type,\n    curriculumType: data.curriculum_type,\n    createdAt: data.created_at,\n    hasPaymentPlan: data.has_payment_plan || false\n  };\n}\nfunction normalizeTransaction(data) {\n  return {\n    id: data.id,\n    feeId: data.fee_id,\n    studentId: data.student_id,\n    payerId: data.payer_id,\n    amount: data.amount,\n    reference: data.reference,\n    provider: data.provider,\n    status: data.status,\n    date: data.created_at\n  };\n}\nfunction mapStatus(status) {\n  const map = {\n    'pending': 'Pending',\n    'partial': 'Partial',\n    'paid': 'Paid',\n    'overdue': 'Overdue',\n    'success': 'Success',\n    'failed': 'Failed'\n  };\n  return map[status.toLowerCase()] || status;\n}","map":{"version":3,"names":["supabase","fetchStudentFees","studentId","data","error","from","select","eq","order","ascending","console","map","normalizeFee","fetchAllFees","assignFee","fee","insert","student_id","title","description","amount","due_date","dueDate","status","paid_amount","curriculum_type","curriculumType","single","initializeTransaction","feeId","reference","provider","user","auth","getUser","fee_id","payer_id","id","verifyTransaction","transaction","txError","update","Error","newPaidAmount","newStatus","updated_at","Date","toISOString","success","message","err","fetchPaymentHistory","query","normalizeTransaction","paidAmount","mapStatus","type","createdAt","created_at","hasPaymentPlan","has_payment_plan","payerId","date","toLowerCase"],"sources":["C:/Users/USER/OneDrive/Desktop/Project/school-app-/lib/payments.ts"],"sourcesContent":["\r\nimport { supabase } from './supabase';\r\nimport { Fee, Transaction, PaymentHistoryItem } from '../types';\r\n\r\n// ===================================\r\n// FEES\r\n// ===================================\r\n\r\n// MOCK DATA STORE\r\n/**\r\n * Fetch fees for a specific student\r\n */\r\nexport async function fetchStudentFees(studentId: number): Promise<Fee[]> {\r\n    const { data, error } = await supabase\r\n        .from('fees')\r\n        .select('*')\r\n        .eq('student_id', studentId)\r\n        .order('due_date', { ascending: true });\r\n\r\n    if (error) {\r\n        console.error('Error fetching fees:', error);\r\n        return [];\r\n    }\r\n\r\n    return data.map(normalizeFee);\r\n}\r\n\r\n/**\r\n * Fetch all fees (for Admin)\r\n */\r\nexport async function fetchAllFees(): Promise<Fee[]> {\r\n    const { data, error } = await supabase\r\n        .from('fees')\r\n        .select('*')\r\n        .order('created_at', { ascending: false });\r\n\r\n    if (error) {\r\n        console.error('Error fetching all fees:', error);\r\n        return [];\r\n    }\r\n    return data.map(normalizeFee);\r\n}\r\n\r\n/**\r\n * Assign a new fee to a student\r\n */\r\nexport async function assignFee(fee: Omit<Fee, 'id' | 'paidAmount' | 'status'>): Promise<Fee> {\r\n    const { data, error } = await supabase\r\n        .from('fees')\r\n        .insert([{\r\n            student_id: fee.studentId,\r\n            title: fee.title,\r\n            description: fee.description,\r\n            amount: fee.amount,\r\n            due_date: fee.dueDate,\r\n            status: 'pending',\r\n            paid_amount: 0,\r\n            curriculum_type: fee.curriculumType || 'General'\r\n        }])\r\n        .select()\r\n        .single();\r\n\r\n    if (error) {\r\n        console.error('Error assigning fee:', error);\r\n        throw error;\r\n    }\r\n    return normalizeFee(data);\r\n}\r\n\r\n\r\n// ===================================\r\n// TRANSACTIONS\r\n// ===================================\r\n\r\n/**\r\n * Initialize a pending transaction before payment\r\n */\r\nexport async function initializeTransaction(\r\n    feeId: number,\r\n    studentId: number,\r\n    amount: number,\r\n    reference: string,\r\n    provider: 'Paystack' | 'Flutterwave' | 'Mobile Money' = 'Paystack'\r\n): Promise<void> {\r\n    // Get current user (payer)\r\n    const { data: { user } } = await supabase.auth.getUser();\r\n\r\n    const { error } = await supabase\r\n        .from('transactions')\r\n        .insert([{\r\n            fee_id: feeId,\r\n            student_id: studentId,\r\n            payer_id: user?.id,\r\n            amount,\r\n            reference,\r\n            provider,\r\n            status: 'pending'\r\n        }]);\r\n\r\n    if (error) {\r\n        console.error('Error initializing transaction:', error);\r\n    }\r\n}\r\n\r\n/**\r\n * Verify Transaction (called after successful payment gateway response)\r\n * This updates the transaction status AND the fee status\r\n */\r\nexport async function verifyTransaction(reference: string): Promise<{ success: boolean; message: string }> {\r\n    try {\r\n        // 1. Mark transaction as success (in a real app, verify with Paystack API first via Edge Function)\r\n        // For MVP, we trust the client-side success callback but we should ideally verify on server.\r\n\r\n        const { data: transaction, error: txError } = await supabase\r\n            .from('transactions')\r\n            .update({ status: 'success' })\r\n            .eq('reference', reference)\r\n            .select()\r\n            .single();\r\n\r\n        if (txError || !transaction) throw new Error('Transaction not found or update failed');\r\n\r\n        // 2. Update the linked Fee\r\n        const feeId = transaction.fee_id;\r\n        if (feeId) {\r\n            // Fetch current fee state\r\n            const { data: fee } = await supabase.from('fees').select('amount, paid_amount').eq('id', feeId).single();\r\n\r\n            if (fee) {\r\n                const newPaidAmount = (fee.paid_amount || 0) + transaction.amount;\r\n                const newStatus = newPaidAmount >= fee.amount ? 'paid' : 'partial';\r\n\r\n                await supabase\r\n                    .from('fees')\r\n                    .update({\r\n                        paid_amount: newPaidAmount,\r\n                        status: newStatus,\r\n                        updated_at: new Date().toISOString()\r\n                    })\r\n                    .eq('id', feeId);\r\n            }\r\n        }\r\n\r\n        return { success: true, message: 'Payment verified successfully' };\r\n\r\n    } catch (err: any) {\r\n        console.error('Payment verification error:', err);\r\n        return { success: false, message: err.message };\r\n    }\r\n}\r\n\r\n/**\r\n * Fetch Payment History\r\n */\r\nexport async function fetchPaymentHistory(studentId?: number): Promise<Transaction[]> {\r\n    let query = supabase\r\n        .from('transactions')\r\n        .select('*')\r\n        .order('created_at', { ascending: false });\r\n\r\n    if (studentId) {\r\n        query = query.eq('student_id', studentId);\r\n    }\r\n\r\n    const { data, error } = await query;\r\n    if (error) return [];\r\n    return data.map(normalizeTransaction);\r\n}\r\n\r\n\r\n// Helpers\r\nfunction normalizeFee(data: any): Fee {\r\n    return {\r\n        id: data.id,\r\n        studentId: data.student_id,\r\n        title: data.title,\r\n        description: data.description,\r\n        amount: data.amount,\r\n        paidAmount: data.paid_amount,\r\n        dueDate: data.due_date,\r\n        status: mapStatus(data.status),\r\n        type: data.type,\r\n        curriculumType: data.curriculum_type,\r\n        createdAt: data.created_at,\r\n        hasPaymentPlan: data.has_payment_plan || false\r\n    };\r\n}\r\n\r\nfunction normalizeTransaction(data: any): Transaction {\r\n    return {\r\n        id: data.id,\r\n        feeId: data.fee_id,\r\n        studentId: data.student_id,\r\n        payerId: data.payer_id,\r\n        amount: data.amount,\r\n        reference: data.reference,\r\n        provider: data.provider,\r\n        status: data.status,\r\n        date: data.created_at\r\n    };\r\n}\r\n\r\nfunction mapStatus(status: string): any {\r\n    // Simple mapper to ensure capitalizations match types\r\n    const map: Record<string, string> = {\r\n        'pending': 'Pending',\r\n        'partial': 'Partial',\r\n        'paid': 'Paid',\r\n        'overdue': 'Overdue',\r\n        'success': 'Success',\r\n        'failed': 'Failed'\r\n    };\r\n    return map[status.toLowerCase()] || status;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}